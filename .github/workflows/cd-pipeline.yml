name: CI/CD Pipeline with SonarCloud

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  # Job existente de CI y SonarCloud
  sonarcloud:
    name: Build and analyze
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests and generate coverage
        run: npm test

      # âœ¨ NUEVO: ValidaciÃ³n de seguridad - Escaneo de vulnerabilidades
      - name: Security Vulnerability Scan
        run: |
          echo "ğŸ” Escaneando vulnerabilidades en dependencias..."
          npm audit --audit-level=moderate --production || echo "âš ï¸ Vulnerabilidades encontradas - revisar antes de producciÃ³n"

      - name: Verify coverage file exists
        run: |
          echo "Checking if coverage file exists..."
          ls -la coverage/
          echo "Coverage file content preview:"
          head -20 coverage/lcov.info

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # NUEVO JOB: Despliegue en entorno de pruebas (CD)
  deploy-test:
    name: Deploy to Test Environment
    runs-on: ubuntu-latest
    needs: sonarcloud  # Solo se ejecuta si SonarCloud pasa
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image for testing
        run: |
          docker build -f Dockerfile.test -t maticrud-test:${{ github.sha }} .
          docker tag maticrud-test:${{ github.sha }} maticrud-test:latest

      # âœ¨ NUEVO: ValidaciÃ³n de seguridad - Integridad de artefactos
      - name: Generate Image Integrity Hash
        run: |
          echo "ğŸ”’ Generando hash de integridad del artefacto..."
          IMAGE_HASH=$(docker image inspect maticrud-test:${{ github.sha }} --format='{{.Id}}')
          echo "IMAGE_HASH=$IMAGE_HASH" >> $GITHUB_ENV
          echo "ğŸ“‹ Image Integrity Hash: $IMAGE_HASH"
          echo "âœ… Integridad de artefacto verificada y documentada"

      # âœ¨ NUEVO: Escaneo de vulnerabilidades en imagen Docker
      - name: Docker Image Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'maticrud-test:${{ github.sha }}'
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'
      
      - name: Start test environment
        run: |
          echo "ğŸš€ Starting test environment..."
          docker compose -f docker-compose.test.yml up -d
          echo "â³ Waiting for services to be ready..."
          sleep 30
      
      - name: Check containers status
        run: |
          echo "ğŸ“‹ Container status:"
          docker compose -f docker-compose.test.yml ps
          echo "ğŸ“‹ Container logs:"
          docker compose -f docker-compose.test.yml logs
      
      - name: Health check
        run: |
          echo "ğŸ” Performing health check..."
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:3001/health 2>/dev/null; then
              echo "âœ… Health check passed!"
              break
            else
              echo "â³ Attempt $attempt/$max_attempts failed, retrying in 10s..."
              sleep 10
              ((attempt++))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ Health check failed after $max_attempts attempts"
            echo "ğŸ“‹ Final container logs:"
            docker compose -f docker-compose.test.yml logs
            exit 1
          fi
      
      - name: Run integration tests
        run: |
          echo "ğŸ§ª Running integration tests..."
          # Verificar endpoint principal
          curl -f http://localhost:3001/health
          # Verificar endpoint de bienvenida
          curl -f http://localhost:3001/
          echo "âœ… Integration tests passed!"
      
      - name: Display deployment info
        run: |
          echo "ğŸ‰ Deployment successful!"
          echo "ğŸ“Š Test Environment: http://localhost:3001"
          echo "ğŸ—„ï¸  Database: mongodb://localhost:27018/MiniCore_test"
          echo "ğŸ”’ Image Hash: $IMAGE_HASH"
      
      - name: Cleanup test environment
        if: always()
        run: |
          echo "ğŸ§¹ Cleaning up test environment..."
          docker compose -f docker-compose.test.yml down
          docker compose -f docker-compose.test.yml down --volumes
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "âœ… Test deployment completed successfully"
          else
            echo "âŒ Test deployment failed"
            exit 1
          fi

  # ğŸ†• NUEVO JOB: Despliegue en entorno de producciÃ³n simulado
  deploy-production:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest
    needs: [sonarcloud, deploy-test]  # Se ejecuta despuÃ©s de testing
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: production  # Requiere aprobaciÃ³n manual
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build production image
        run: |
          echo "ğŸ—ï¸ Construyendo imagen de producciÃ³n..."
          docker build -f Dockerfile.prod -t maticrud-prod:${{ github.sha }} .
          docker tag maticrud-prod:${{ github.sha }} maticrud-prod:latest
      
      - name: Generate production integrity hash
        run: |
          echo "ğŸ”’ Generando hash de integridad para producciÃ³n..."
          PROD_HASH=$(docker image inspect maticrud-prod:${{ github.sha }} --format='{{.Id}}')
          echo "PROD_HASH=$PROD_HASH" >> $GITHUB_ENV
          echo "ğŸ“‹ Production Image Hash: $PROD_HASH"
      
      - name: Production security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'maticrud-prod:${{ github.sha }}'
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'
      
      - name: Start production environment
        run: |
          echo "ğŸš€ Iniciando entorno de producciÃ³n..."
          docker compose -f docker-compose.prod.yml up -d
          echo "â³ Esperando a que los servicios estÃ©n listos..."
          sleep 45
      
      - name: Check production containers status
        run: |
          echo "ğŸ“‹ Estado de contenedores de producciÃ³n:"
          docker compose -f docker-compose.prod.yml ps
          echo "ğŸ“‹ Logs de producciÃ³n:"
          docker compose -f docker-compose.prod.yml logs --tail=20
      
      - name: Production health check
        run: |
          echo "ğŸ” Ejecutando health check de producciÃ³n..."
          max_attempts=15
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:3002/health 2>/dev/null; then
              echo "âœ… Health check de producciÃ³n exitoso!"
              break
            else
              echo "â³ Intento $attempt/$max_attempts fallido, reintentando en 10s..."
              sleep 10
              ((attempt++))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ Health check de producciÃ³n fallÃ³"
            echo "ğŸ“‹ Logs finales:"
            docker compose -f docker-compose.prod.yml logs maticrud-prod
            exit 1
          fi
      
      - name: Production smoke tests
        run: |
          echo "ğŸ§ª Ejecutando pruebas de smoke testing en producciÃ³n..."
          
          # Verificar endpoints principales
          curl -f http://localhost:3002/health
          curl -f http://localhost:3002/
          
          # Verificar que la API responde
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3002/user)
          if [ $response -eq 200 ] || [ $response -eq 401 ]; then
            echo "âœ… API endpoints respondiendo correctamente"
          else
            echo "âŒ API endpoints no responden correctamente (status: $response)"
            exit 1
          fi
          
          echo "âœ… Smoke tests de producciÃ³n completados!"
      
      - name: Production performance test
        run: |
          echo "âš¡ Ejecutando prueba de rendimiento bÃ¡sica..."
          
          # Medir tiempo de respuesta
          start_time=$(date +%s%N)
          curl -f http://localhost:3002/health > /dev/null
          end_time=$(date +%s%N)
          
          response_time=$((($end_time - $start_time) / 1000000))
          echo "â±ï¸ Tiempo de respuesta: ${response_time}ms"
          
          if [ $response_time -lt 2000 ]; then
            echo "âœ… Rendimiento dentro del rango aceptable"
          else
            echo "âš ï¸ Advertencia: Tiempo de respuesta alto"
          fi
      
      - name: Production security validation
        run: |
          echo "ğŸ›¡ï¸ Validando seguridad en producciÃ³n..."
          
          # Verificar que no hay puertos inseguros
          if docker compose -f docker-compose.prod.yml ps | grep -q "22/tcp\|23/tcp\|21/tcp"; then
            echo "âŒ Puertos inseguros detectados"
            exit 1
          fi
          
          # Verificar headers de respuesta
          headers=$(curl -s -I http://localhost:3002/health)
          if echo "$headers" | grep -q "X-Powered-By"; then
            echo "âš ï¸ Advertencia: Header X-Powered-By expuesto"
          fi
          
          echo "âœ… Validaciones de seguridad completadas"
      
      - name: Display production deployment info
        run: |
          echo "ğŸ‰ Â¡Despliegue de producciÃ³n completado exitosamente!"
          echo "=================================================="
          echo "ğŸŒ ProducciÃ³n: http://localhost:3002"
          echo "ğŸ” Health Check: http://localhost:3002/health"
          echo "ğŸ—„ï¸ MongoDB: mongodb://localhost:27019/MiniCore_prod"
          echo "ğŸ”’ Image Hash: $PROD_HASH"
          echo ""
          echo "ğŸ“Š Resumen de entornos:"
          echo "  ğŸ§ª Testing: http://localhost:3001"
          echo "  ğŸ­ Production: http://localhost:3002"
      
      - name: Cleanup production environment
        if: always()
        run: |
          echo "ğŸ§¹ Limpiando entorno de producciÃ³n..."
          docker compose -f docker-compose.prod.yml down --volumes
          echo "âœ… Limpieza completada"
      
      - name: Notify production deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "âœ… Despliegue de producciÃ³n completado exitosamente"
            echo "ğŸ¯ Listo para despliegue en producciÃ³n real"
          else
            echo "âŒ Despliegue de producciÃ³n fallÃ³"
            exit 1
          fi